; TSR Example

section .text
org 0x100

; Jump to our entry point
begin: jmp entry
intHook: jmp hook

start_segments db `DOS loaded the COM with this:\r\n$`

previous_hook_str db "Calling previous hook is at"
previous_hook_address_str db ` XXXX:XXXX\r\n$`

register_dump db `CS: XXXX\r\nDS: XXXX\r\nSS: XXXX\r\n$`

previous_hook_offset: dw 0
previous_hook_segment: dw 0

hook:
	; When we come into an interrupt, only the
	; code segment and instruction pointer are preserved
	; for us. It's the responsibility of the handler to
	; preserve this information

	; This is saved on the application's local stack, which is fine
	; for now (FreeDOS does the same thing internally) as long as
	; we're not putting any large items on it. We'll look at setting
	; up a local stack later

	pushf ; Save flags
	pusha ; push all general registers to the stack

	; Setup segments
	push ds
	push es

	; For interrupt handlers, CS=DS normally, and SS either points
	; at the application stack (aka, whatever was running before we are)
	; or at a local stack setup by the TSR. On x86, its not possible to directly
	; copy from one segment register to another, so we'll use AX as a scratch
	
	mov ax, cs
	mov ds, ax
	mov es, ax

	; CDECL call
	call _segmentDump

    mov ah, 9
    mov dx, register_dump
    int 0x21

	; Pass the call down to previous interrupt handlers
	call printPreviousHook

	pushf ; pushf is required because iret expects to pop flags
	call far [previous_hook_offset]

	; We're done, restore to previous state
	pop es
	pop ds
	popa
	popf

	iret

; void addressToHex(int num, char string[4])
;
; addressToHex takes an int (16-bit) and converts it to
; a hexadecimal representation 
_addressToHex:
	; Setup stack frame
	push bp
	mov bp, sp

	; The stack now has the following layout
	; bp[+2] stack frame
	; bp[+4] num
	; bp[+6] string

	; Clear out our registers
	xor ax, ax
	xor dx, dx

	; Load the string pointer to DI, and our base
	; to BX to do the int -> HEX conversion
	mov di, [bp+6]
	add di, 4
	
	; Load the number into AX for div
	; div operates on the size of the register passed to it (8 or 16 bit),
	; when given a 16-bit divisor, it uses DX:AX to generate a 32-bit input
	; The quotant goes in AX, and the reaminer goes into DX.

	mov ax, [bp+4]
	mov bx, 16
	
	; CX marks which digit we're writing out for use ith dl
	mov cx, 4

	; By dividing by 16, and then operating on the remainder, we can
	; convert from hex by adding 0x30 to convert from a literial number
	; to a digit, or 41 for A-F

	processLoop:
		div bx

		; Covert from int to hex
		; 0-9, add 0x30
		cmp dx, 9
		jg handleHex
		
		; Handle 0-9
		add dl, 0x30
		jmp loadByte
	
	handleHex: 
		sub dl, 10
		add dl, 0x41

	loadByte:
		mov byte [di], dl
		dec di
	
		; check remainder == 0 to know if we're done
		xor dx, dx

		; dec will set the FLAG Z byte when cx == 0
		dec cx
		jnz processLoop
	
	; Return pointer at end position in AX
	mov ax, dx
	
	pop bp
	ret

; Dumps the state of the segment registers
_segmentDump:
	push bp
	mov bp, sp

	; We'll use AX as a pointer to where we are in the string
	mov ax, register_dump
	
	; We'll use BX as a scratch register to hold the value we want to
	; convert to ASCII
	xor bx, bx

	; We have a pattern to follow, right now we have CS: XXXX, then newline, etc so
	; to print out each register, we add three to the pointer (since we start pointing at
	; 'C', call _addressToHex, then add 5 (newine+XX: ), and continue
	
	add ax, 3
	
	; Callee doesnt' perserve registers, we need to do that before
	; entering a function
	push ax
	
	; CS comes first	
	push ax ; String pointer
	mov bx, cs
	push bx
	call _addressToHex
	add sp, 4 ; pop the stack clean
	
	; And bring registers back
	pop ax
	add ax, 10 ; Move to start of XXXX in DS
	push ax
	
	; Convert DS
	push ax ; String pointer
	mov bx, ds
	push bx
	call _addressToHex
	add sp, 4 ; pop the stack clean

	pop ax
	add ax, 10 ; Move to start of XXXX in DS
	push ax
	
	; Convert SS
	push ax ; String pointer
	mov bx, ss
	push bx
	call _addressToHex
	add sp, 6 ; pop stack and remove ax

	
	pop bp
	ret
; void printPreviousHook()
;
; Given a previously stored hook in the global variables
; previous_hook_segment, and previous_hook_offset, print out
; a string saying where we're going to

printPreviousHook:
	push bp
	mov bp, sp

	; Put the Segment string in place
	push previous_hook_address_str
	mov ax, [previous_hook_segment]
	push ax
	call _addressToHex
	add sp, 4

	; Now the offset
	mov ax, previous_hook_address_str
	add ax, 5
	push ax
	mov ax, [previous_hook_offset]
	push ax
	call _addressToHex
	add sp, 4

	; Now print the the full string from the start
	mov ah, 9
    mov dx, previous_hook_str
    int 0x21
	pop bp
	ret

; Program entry point
entry:
	; Initialize our stack pointer
	mov bp, sp

	; Save previous int vector

	; Get previous interrupt hook
	mov ax, 0x3566
	int 0x21

	mov [previous_hook_offset], bx
	mov [previous_hook_segment], es

	; Install interrupt handler
	xor ax, ax
	mov ax, 0x2566
	mov dx, intHook
	int 0x21

	mov ah, 9
    mov dx, start_segments
    int 0x21
	call _segmentDump

	; Calculate from the top of the file to the entry point
	; excluding this final section as its not used after the TSR is
	; installed.

	mov dx, begin
	sub dx, entry
	shr dx, 4
	add dx, 17
	mov ax, 0x3100
	int 0x21
	